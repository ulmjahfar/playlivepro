const express = require('express');
const ExcelJS = require('exceljs');
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');
const Player = require('../models/Player');
const Tournament = require('../models/Tournament');
const Team = require('../models/Team');
const { authenticateToken, authorizeRoles } = require('./authRoutes');

const router = express.Router();

// Export players as Excel
router.get('/players/excel/:tournamentCode', authenticateToken, authorizeRoles('SuperAdmin', 'TournamentAdmin'), async (req, res) => {
  try {
    const players = await Player.find({ tournamentCode: req.params.tournamentCode });
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Players');

    worksheet.columns = [
      { header: 'Player ID', key: 'playerId', width: 15 },
      { header: 'Name', key: 'name', width: 20 },
      { header: 'Role', key: 'role', width: 15 },
      { header: 'City', key: 'city', width: 15 },
      { header: 'Mobile', key: 'mobile', width: 15 },
      { header: 'Auction Status', key: 'auctionStatus', width: 15 },
      { header: 'Sold Price', key: 'soldPrice', width: 15 }
    ];

    players.forEach(player => {
      worksheet.addRow({
        playerId: player.playerId,
        name: player.name,
        role: player.role,
        city: player.city,
        mobile: player.mobile,
        auctionStatus: player.auctionStatus,
        soldPrice: player.soldPrice || 'N/A'
      });
    });

    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename=players_${req.params.tournamentCode}.xlsx`);

    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: 'Error generating Excel' });
  }
});

// Export tournament summary as PDF (must come before /:code/summary to avoid route conflicts)
router.get('/summary/pdf/:tournamentCode', authenticateToken, authorizeRoles('SuperAdmin', 'TournamentAdmin'), async (req, res) => {
  try {
    const players = await Player.find({ tournamentCode: req.params.tournamentCode });
    const tournament = await Tournament.findOne({ code: req.params.tournamentCode });

    const totalPlayers = players.length;
    const soldPlayers = players.filter(p => p.auctionStatus === 'Sold').length;
    const unsoldPlayers = totalPlayers - soldPlayers;
    const totalValue = players.reduce((sum, p) => sum + (p.soldPrice || 0), 0);

    const doc = new PDFDocument();
    const fileName = `summary_${req.params.tournamentCode}.pdf`;
    const filePath = path.join(__dirname, '../reports', fileName);

    if (!fs.existsSync(path.join(__dirname, '../reports'))) {
      fs.mkdirSync(path.join(__dirname, '../reports'), { recursive: true });
    }

    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);

    doc.fontSize(20).text('Tournament Summary', { align: 'center' });
    doc.fontSize(16).text(tournament.name, { align: 'center' });
    doc.moveDown();

    doc.fontSize(14).text(`Total Players: ${totalPlayers}`);
    doc.text(`Sold Players: ${soldPlayers}`);
    doc.text(`Unsold Players: ${unsoldPlayers}`);
    doc.text(`Total Auction Value: â‚¹${totalValue}`);
    doc.moveDown();

    doc.fontSize(10).text('Generated by PlayLive', { align: 'center' });

    doc.end();

    stream.on('finish', () => {
      res.download(filePath, fileName, (err) => {
        if (err) console.error(err);
      });
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ success: false, message: 'Error generating PDF' });
  }
});

// Get tournament analytics - PUBLIC VERSION (for comprehensive print page)
router.get('/:code/analytics/public', async (req, res) => {
  try {
    const { code } = req.params;
    const tournament = await Tournament.findOne({ code }).populate('adminId', 'username name');
    
    if (!tournament) {
      return res.status(404).json({ success: false, message: 'Tournament not found' });
    }

    // Fetch all players and teams
    const [players, teams] = await Promise.all([
      Player.find({ tournamentCode: code }).sort({ registeredAt: 1 }),
      Team.find({ tournamentCode: code })
    ]);

    // Calculate statistics
    const totalPlayers = players.length;
    const maxPlayers = tournament.maxPlayers || tournament.playerPoolSize || 100;
    const registrationCapacityPercent = maxPlayers > 0 ? Math.round((totalPlayers / maxPlayers) * 100) : 0;
    
    const activeTeams = teams.length;
    const averagePlayersPerTeam = activeTeams > 0 ? Math.round(totalPlayers / activeTeams) : 0;

    // Revenue calculations
    const soldPlayers = players.filter(p => p.auctionStatus === 'Sold');
    const totalRevenue = soldPlayers.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
    
    const pendingPlayers = players.filter(p => p.auctionStatus === 'Pending');
    const pendingPayments = pendingPlayers.length * (tournament.basePrice || 1000);
    
    const soldPlayersCount = soldPlayers.length;
    const unsoldPlayersCount = players.filter(p => p.auctionStatus === 'Unsold' || p.auctionStatus === 'Available').length;

    // Revenue breakdown
    const playerRegistrationRevenue = totalPlayers * (tournament.basePrice || 1000);
    const teamRegistrationRevenue = activeTeams * 10000; // Estimated team registration fee
    const auctionRevenue = totalRevenue;
    const sponsorshipRevenue = Math.round(auctionRevenue * 0.15); // 15% estimate

    // Generate registration timeline (weekly)
    const timeline = [];
    if (players.length > 0 && players[0].registeredAt) {
      const firstRegistration = new Date(players[0].registeredAt);
      const lastRegistration = new Date(players[players.length - 1].registeredAt);
      const totalDays = Math.max(1, Math.ceil((lastRegistration - firstRegistration) / (1000 * 60 * 60 * 24)));
      
      const weeks = Math.max(1, Math.min(Math.ceil(totalDays / 7), 12)); // Max 12 weeks
      
      for (let i = 0; i < weeks; i++) {
        const weekStartDate = new Date(firstRegistration);
        weekStartDate.setDate(weekStartDate.getDate() + (i * 7));
        const weekEndDate = new Date(weekStartDate);
        weekEndDate.setDate(weekEndDate.getDate() + 6);
        
        const weekPlayers = players.filter(p => {
          const regDate = new Date(p.registeredAt);
          return regDate >= weekStartDate && regDate <= weekEndDate;
        }).length;
        
        const progress = maxPlayers > 0 ? Math.min(100, Math.round((weekPlayers / maxPlayers) * 100)) : 0;
        
        timeline.push({
          week: i + 1,
          date: weekStartDate.toLocaleDateString('en-IN', { day: '2-digit', month: 'short' }),
          dateEnd: weekEndDate.toLocaleDateString('en-IN', { day: '2-digit', month: 'short' }),
          players: weekPlayers,
          progress: progress
        });
      }
    } else {
      // Fallback timeline
      for (let i = 0; i < 4; i++) {
        timeline.push({
          week: i + 1,
          date: `Week ${i + 1}`,
          dateEnd: '',
          players: 0,
          progress: 0
        });
      }
    }

    // Top performers (top 5 by soldPrice)
    const topPerformers = players
      .filter(p => p.auctionStatus === 'Sold' && p.soldPrice)
      .sort((a, b) => (b.soldPrice || 0) - (a.soldPrice || 0))
      .slice(0, 5)
      .map(p => ({
        name: p.name || 'N/A',
        role: p.role || 'N/A',
        team: p.soldToName || 'Unassigned',
        price: p.soldPrice || 0
      }));

    // Team performance data
    const teamPerformance = await Promise.all(teams.map(async (team) => {
      const teamPlayers = players.filter(p => p.soldTo && p.soldTo.toString() === team._id.toString());
      const teamRevenue = teamPlayers.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
      const wins = 0; // Placeholder - no wins data in model
      
      return {
        teamId: team.teamId,
        name: team.name,
        players: teamPlayers.length,
        wins: wins,
        revenue: teamRevenue
      };
    }));

    res.json({
      success: true,
      tournament: {
        name: tournament.name,
        code: tournament.code,
        status: tournament.status,
        sport: tournament.sport,
        location: tournament.location,
        subtitle: tournament.description || `${tournament.sport} Tournament`,
        logo: tournament.logo,
        reportPosters: tournament.reportPosters || {}
      },
      statistics: {
        totalPlayers: {
          count: totalPlayers,
          capacity: maxPlayers,
          percent: registrationCapacityPercent
        },
        activeTeams: {
          count: activeTeams,
          averagePlayersPerTeam: averagePlayersPerTeam
        },
        totalRevenue: totalRevenue,
        pendingPayments: pendingPayments,
        soldPlayers: soldPlayersCount,
        unsoldPlayers: unsoldPlayersCount
      },
      timeline: timeline,
      topPerformers: topPerformers,
      teamPerformance: teamPerformance.sort((a, b) => (b.revenue || 0) - (a.revenue || 0)),
      revenueBreakdown: {
        playerRegistrations: playerRegistrationRevenue,
        teamRegistrations: teamRegistrationRevenue,
        auctionRevenue: auctionRevenue,
        sponsorship: sponsorshipRevenue
      }
    });
  } catch (error) {
    console.error('Error fetching tournament analytics:', error);
    res.status(500).json({ success: false, message: 'Error fetching tournament analytics' });
  }
});

// Get tournament analytics (comprehensive data for analytics page)
router.get('/:code/analytics', authenticateToken, authorizeRoles('SuperAdmin', 'TournamentAdmin'), async (req, res) => {
  try {
    const { code } = req.params;
    const tournament = await Tournament.findOne({ code }).populate('adminId', 'username name');
    
    if (!tournament) {
      return res.status(404).json({ success: false, message: 'Tournament not found' });
    }

    // Fetch all players and teams
    const [players, teams] = await Promise.all([
      Player.find({ tournamentCode: code }).sort({ registeredAt: 1 }),
      Team.find({ tournamentCode: code })
    ]);

    // Calculate statistics
    const totalPlayers = players.length;
    const maxPlayers = tournament.maxPlayers || tournament.playerPoolSize || 100;
    const registrationCapacityPercent = maxPlayers > 0 ? Math.round((totalPlayers / maxPlayers) * 100) : 0;
    
    const activeTeams = teams.length;
    const averagePlayersPerTeam = activeTeams > 0 ? Math.round(totalPlayers / activeTeams) : 0;

    // Revenue calculations
    const soldPlayers = players.filter(p => p.auctionStatus === 'Sold');
    const totalRevenue = soldPlayers.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
    
    const pendingPlayers = players.filter(p => p.auctionStatus === 'Pending');
    const pendingPayments = pendingPlayers.length * (tournament.basePrice || 1000);
    
    const soldPlayersCount = soldPlayers.length;
    const unsoldPlayersCount = players.filter(p => p.auctionStatus === 'Unsold' || p.auctionStatus === 'Available').length;

    // Revenue breakdown
    const playerRegistrationRevenue = totalPlayers * (tournament.basePrice || 1000);
    const teamRegistrationRevenue = activeTeams * 10000; // Estimated team registration fee
    const auctionRevenue = totalRevenue;
    const sponsorshipRevenue = Math.round(auctionRevenue * 0.15); // 15% estimate

    // Generate registration timeline (weekly)
    const timeline = [];
    if (players.length > 0 && players[0].registeredAt) {
      const firstRegistration = new Date(players[0].registeredAt);
      const lastRegistration = new Date(players[players.length - 1].registeredAt);
      const totalDays = Math.max(1, Math.ceil((lastRegistration - firstRegistration) / (1000 * 60 * 60 * 24)));
      
      const weeks = Math.max(1, Math.min(Math.ceil(totalDays / 7), 12)); // Max 12 weeks
      
      for (let i = 0; i < weeks; i++) {
        const weekStartDate = new Date(firstRegistration);
        weekStartDate.setDate(weekStartDate.getDate() + (i * 7));
        const weekEndDate = new Date(weekStartDate);
        weekEndDate.setDate(weekEndDate.getDate() + 6);
        
        const weekPlayers = players.filter(p => {
          const regDate = new Date(p.registeredAt);
          return regDate >= weekStartDate && regDate <= weekEndDate;
        }).length;
        
        const progress = maxPlayers > 0 ? Math.min(100, Math.round((weekPlayers / maxPlayers) * 100)) : 0;
        
        timeline.push({
          week: i + 1,
          date: weekStartDate.toLocaleDateString('en-IN', { day: '2-digit', month: 'short' }),
          dateEnd: weekEndDate.toLocaleDateString('en-IN', { day: '2-digit', month: 'short' }),
          players: weekPlayers,
          progress: progress
        });
      }
    } else {
      // Fallback timeline
      for (let i = 0; i < 4; i++) {
        timeline.push({
          week: i + 1,
          date: `Week ${i + 1}`,
          dateEnd: '',
          players: 0,
          progress: 0
        });
      }
    }

    // Top performers (top 5 by soldPrice)
    const topPerformers = players
      .filter(p => p.auctionStatus === 'Sold' && p.soldPrice)
      .sort((a, b) => (b.soldPrice || 0) - (a.soldPrice || 0))
      .slice(0, 5)
      .map(p => ({
        name: p.name || 'N/A',
        role: p.role || 'N/A',
        team: p.soldToName || 'Unassigned',
        price: p.soldPrice || 0
      }));

    // Team performance data
    const teamPerformance = await Promise.all(teams.map(async (team) => {
      const teamPlayers = players.filter(p => p.soldTo && p.soldTo.toString() === team._id.toString());
      const teamRevenue = teamPlayers.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
      const wins = 0; // Placeholder - no wins data in model
      
      return {
        teamId: team.teamId,
        name: team.name,
        players: teamPlayers.length,
        wins: wins,
        revenue: teamRevenue
      };
    }));

    res.json({
      success: true,
      tournament: {
        name: tournament.name,
        code: tournament.code,
        status: tournament.status,
        sport: tournament.sport,
        location: tournament.location,
        subtitle: tournament.description || `${tournament.sport} Tournament`,
        logo: tournament.logo,
        reportPosters: tournament.reportPosters || {}
      },
      statistics: {
        totalPlayers: {
          count: totalPlayers,
          capacity: maxPlayers,
          percent: registrationCapacityPercent
        },
        activeTeams: {
          count: activeTeams,
          averagePlayersPerTeam: averagePlayersPerTeam
        },
        totalRevenue: totalRevenue,
        pendingPayments: pendingPayments,
        soldPlayers: soldPlayersCount,
        unsoldPlayers: unsoldPlayersCount
      },
      timeline: timeline,
      topPerformers: topPerformers,
      teamPerformance: teamPerformance.sort((a, b) => (b.revenue || 0) - (a.revenue || 0)),
      revenueBreakdown: {
        playerRegistrations: playerRegistrationRevenue,
        teamRegistrations: teamRegistrationRevenue,
        auctionRevenue: auctionRevenue,
        sponsorship: sponsorshipRevenue
      }
    });
  } catch (error) {
    console.error('Error fetching tournament analytics:', error);
    res.status(500).json({ success: false, message: 'Error fetching tournament analytics' });
  }
});

// Get tournament reports summary
router.get('/:code/summary', authenticateToken, authorizeRoles('SuperAdmin', 'TournamentAdmin'), async (req, res) => {
  try {
    const { code } = req.params;
    const tournament = await Tournament.findOne({ code });
    
    if (!tournament) {
      return res.status(404).json({ success: false, message: 'Tournament not found' });
    }

    // Get all players for the tournament
    const players = await Player.find({ tournamentCode: code }).select('registeredAt soldPrice auctionStatus').sort({ registeredAt: 1 });

    // Calculate total revenue from sold players
    const totalRevenue = players
      .filter(p => p.auctionStatus === 'Sold' && p.soldPrice)
      .reduce((sum, p) => sum + (p.soldPrice || 0), 0);

    // Calculate pending payments (players with Pending status)
    const pendingPlayers = players.filter(p => p.auctionStatus === 'Pending');
    const pendingPayments = pendingPlayers.length * (tournament.basePrice || 1000); // Estimate based on base price

    // Generate registration timeline
    const timeline = [];
    if (players.length > 0) {
      const firstRegistration = new Date(players[0].registeredAt);
      const lastRegistration = new Date(players[players.length - 1].registeredAt);
      const totalDays = Math.ceil((lastRegistration - firstRegistration) / (1000 * 60 * 60 * 24)) || 1;
      
      // Create weekly timeline data
      const weeks = Math.max(1, Math.ceil(totalDays / 7));
      const playersPerWeek = players.length / weeks;
      
      for (let i = 0; i < weeks; i++) {
        const weekStart = i * playersPerWeek;
        const weekEnd = Math.min((i + 1) * playersPerWeek, players.length);
        const weekPlayers = Math.ceil(weekEnd) - Math.floor(weekStart);
        const maxPlayers = tournament.maxPlayers || 100;
        const progress = Math.min(100, Math.round((weekPlayers / maxPlayers) * 100));
        
        timeline.push({
          date: `Week ${i + 1}`,
          value: progress
        });
      }
    } else {
      // Fallback timeline if no players
      timeline.push(
        { date: 'Week 1', value: 0 },
        { date: 'Week 2', value: 0 },
        { date: 'Week 3', value: 0 },
        { date: 'Week 4', value: 0 },
        { date: 'Week 5', value: 0 }
      );
    }

    res.json({
      success: true,
      timeline,
      totalRevenue,
      pendingPayments
    });
  } catch (error) {
    console.error('Error fetching report summary:', error);
    res.status(500).json({ success: false, message: 'Error fetching report summary' });
  }
});

// Export analytics as Excel
router.get('/analytics/excel/:tournamentCode', authenticateToken, authorizeRoles('SuperAdmin', 'TournamentAdmin'), async (req, res) => {
  try {
    const { tournamentCode } = req.params;
    const tournament = await Tournament.findOne({ code: tournamentCode });
    
    if (!tournament) {
      return res.status(404).json({ success: false, message: 'Tournament not found' });
    }

    const [players, teams] = await Promise.all([
      Player.find({ tournamentCode }),
      Team.find({ tournamentCode })
    ]);

    const workbook = new ExcelJS.Workbook();
    
    // Summary Sheet
    const summarySheet = workbook.addWorksheet('Summary');
    summarySheet.columns = [
      { header: 'Metric', key: 'metric', width: 30 },
      { header: 'Value', key: 'value', width: 20 }
    ];

    const totalPlayers = players.length;
    const soldPlayers = players.filter(p => p.auctionStatus === 'Sold').length;
    const totalRevenue = players.filter(p => p.auctionStatus === 'Sold').reduce((sum, p) => sum + (p.soldPrice || 0), 0);
    
    summarySheet.addRows([
      { metric: 'Tournament Name', value: tournament.name },
      { metric: 'Tournament Code', value: tournament.code },
      { metric: 'Status', value: tournament.status },
      { metric: 'Total Players', value: totalPlayers },
      { metric: 'Active Teams', value: teams.length },
      { metric: 'Sold Players', value: soldPlayers },
      { metric: 'Unsold Players', value: totalPlayers - soldPlayers },
      { metric: 'Total Revenue', value: totalRevenue }
    ]);

    // Players Sheet
    const playersSheet = workbook.addWorksheet('Players');
    playersSheet.columns = [
      { header: 'Player ID', key: 'playerId', width: 15 },
      { header: 'Name', key: 'name', width: 20 },
      { header: 'Role', key: 'role', width: 15 },
      { header: 'Team', key: 'team', width: 20 },
      { header: 'Sold Price', key: 'soldPrice', width: 15 },
      { header: 'Status', key: 'status', width: 15 }
    ];

    players.forEach(player => {
      playersSheet.addRow({
        playerId: player.playerId,
        name: player.name,
        role: player.role,
        team: player.soldToName || 'Unassigned',
        soldPrice: player.soldPrice || 0,
        status: player.auctionStatus
      });
    });

    // Teams Sheet
    const teamsSheet = workbook.addWorksheet('Teams');
    teamsSheet.columns = [
      { header: 'Team ID', key: 'teamId', width: 15 },
      { header: 'Team Name', key: 'name', width: 20 },
      { header: 'Players', key: 'players', width: 10 },
      { header: 'Revenue', key: 'revenue', width: 15 }
    ];

    teams.forEach(team => {
      const teamPlayers = players.filter(p => p.soldTo && p.soldTo.toString() === team._id.toString());
      const teamRevenue = teamPlayers.reduce((sum, p) => sum + (p.soldPrice || 0), 0);
      
      teamsSheet.addRow({
        teamId: team.teamId,
        name: team.name,
        players: teamPlayers.length,
        revenue: teamRevenue
      });
    });

    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename=tournament_analytics_${tournamentCode}.xlsx`);

    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    console.error('Error generating analytics Excel:', error);
    res.status(500).json({ success: false, message: 'Error generating Excel' });
  }
});

module.exports = router;
